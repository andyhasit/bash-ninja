'''
Change to accept a directory with multiple config files.

Inside a config file you can write normal bash code, which gets copied,
or directives

--prefix ="hm"

--files = "/home/project/phoebus" 
--dirs


-------------------------------

Nope. 

Work with python files directly

my_aliases.py which imports the lib tools

says where it writes to.

functions to process raw, process as aliases, or utils like explore, cd, edit

ac = AliasCollector()
ac.process_pairs(
''
facebook | http:
'',
lambda x: 'hm.web.' + x, #optional
lambda x: 'web' + x,  #optional
)

ac.process_dirs(
    basepath,
    filter,
    alias_fn,
    command_fn,
)
ac.add_raw(raw_text)

ac.chain('hm.activate', ''
hm.cd.home

You can also choose whether to allow overwrites or not

'')


'''


import sys, os
from collections import defaultdict

def extract(filepath):
    aliases = {}
    with open(filepath) as fp:
        for linenumber, line in enumerate(fp):
            try:
                if line_is_to_be_used(line):
                    alias, command = splitline(line)
                    if aliases.has_key(alias):
                        raise ValueError("Alias {0} already exists".format(alias))
                    aliases[alias] = command
            except Exception as e:
                print("problem at line {0}".format(linenumber))
                print(e)
    return aliases

def line_is_to_be_used(line):
    line = line.strip()
    return not(line == '' or line.startswith("#"))

def splitline(line):
    end = line.index('|')
    alias = line[0: end].strip()
    command = line[end + 1:].strip()
    return alias, command

def write_alias_lists_to_file(alias_file, *alias_dicts):
    total = 0
    with open(alias_file, 'w+') as fd:
        fd.write("# Do not make changes directly in here.\n")
        fd.write("# This file is generated by the script:\n")
        fd.write("#\n#    {0}\n".format(THIS_SCRIPT))
        fd.write("# Which is fed by:\n")
        fd.write("# \n#    {0}\n".format(CONF_FILE))
        fd.write("# Please edit the latter instead.\n\n")
        for alias_dict in alias_dicts:
            for k in alias_dict:
                fd.write("alias {0}='{1}'\n".format(k, alias_dict[k]))
                total += 1
    print("Wrote {0} aliases to file: {1}".format(total, alias_file))

if __name__ == '__main__':
    if len(sys.argv) != 3:
        print('Call with CONF_FILE ALIASES_FILE')
        exit(1)
    THIS_SCRIPT = os.path.realpath(__file__)
    CONF_FILE = os.path.realpath(sys.argv[1])
    ALIASES_FILE = os.path.realpath(sys.argv[2])
    print('CONF_FILE: ' + CONF_FILE)
    print('ALIASES_FILE: ' + ALIASES_FILE)
    aliases = extract(CONF_FILE)
    write_alias_lists_to_file(ALIASES_FILE, aliases)


    if False:
        print 'nano "{CONF_FILE}" && python "{THIS_SCRIPT}" \
    "{CONF_FILE}" "{ALIASES_FILE}" && source "{ALIASES_FILE}"'.format(
            ALIASES_FILE=ALIASES_FILE,
            CONF_FILE=CONF_FILE,
            THIS_SCRIPT=THIS_SCRIPT
            )

        print ("If running first time, type:")
        print ("source {0}".format(ALIASES_FILE))


